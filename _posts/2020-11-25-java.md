---
layout: post  
title: Java学习笔记
categories: 笔记
tags: Java
author: Ko_teiru
---

* content
{:toc}

> Java学习笔记

纯自用，瞎写





## java数据类型 
###  基本数据类型
整数型：int（整），short（短整），long（长整），byte（位）  
浮点型：double（单精度），float（双精度）（两个都是表示小数）  
字符型：char（用于输出字符  
布尔型：boolean（真true或假false）  
### 数据的溢出  
每个数据类型有相应的数值表示范围，当一个数字已经是最大或最小值的时候，在进行增加或减少操作，就会产生数据的溢出。 
当一个值的最大值+1，他就会变成该值的最小值。反之最小值-1他就会变成最大值。 

**`max`的使用**
max可以用来选出两个相同类型变量之间的那个更大的变量，也可用来求一个数据类型的最大值，例如  

```java
int max=Integer.MAX_VALUE;//赋予max int类型的最大值
```
**`min`的使用**

min的使用与max无异，只是一个表示最大（max）一个表示最小罢了（min）。 
```java
int min=Integer.MIN_VALUE; //min变量的最小值 -2147483648
```
当然，`MAX_VALUE`或者`MIN_VALUE`也可以和别的数据类型来使用，比如说：
```java
long max=Long.MAX_VALUE;//9223372036854775807
long min=Long.MIN_VALUE;//-9223372036854775808
```

### char字符的转义  
> 常用的转义字符    
其中1~5是常见的功能类转义， 6~8为直接输出\后的字符。

|No. | 转义字符 | 描述 | No. | 转义字符 | 描述 | 
| :----: | :----: | :----: | :----: | :----: | :----: | 
|1|\f|换页|2| \b |倒退一格|
|3|\r|归位|4|\t|制表位Tab|
|5|\n|换行|6| \\\ |反斜线|
|7|\\' |单引号|8|\\" |双引号

```java
Char 变量名='值'; //部分值得用单引号包围
```
> 这个“值”可以直接填入单引号中，也可以直接用数字定义（ascII码）  
> 数字定义字符变量时不用使用单引号
*比如下面的例子* 

```java
char ch1='a'; //为 a
char ch2=97; //同样为 a
```
```java
char ch1='\"'; //其中的\表示直接输出字符，故为 "
char ch2='\\'; //为 \
char n='\n'; //n表示换行
System.out.println(ch1+n+ch2); //可以在输出时加上n用来换行
```
> 反斜线后面接符号一般会直接输出该符号

### 浮点类型  
> 浮点类型说直白点就是小数（？），因为int，short，long等类型只能表示整数，而要表示小数只能用浮点类型了。  

*注意:有时候给`long`、`float`、`double`套上一个较大的值的时候，会出现一个错误，原因可能是编辑器把数值当成了int类型，这时候需要在数值后面加上对应数据类型的首字母即可解决。<sup>[参考链接](https://my.oschina.net/u/2308739/blog/633959)</sup>  
```java
long x=99999999999l//不分大小写
float y=3.14F
double z=3.00000000D
```  
> 默认类型：
整数（1、2、3）一般默认是int类型，而小数（1.1、1.2、1.3）的默认类型是double类型。  

### 布尔类型  
定义一个变量的真（true）假（false）  
~~true与false不只在java，在别的地方中也很常见，比如说aria2和vccode的配置文件中。~~  
*布尔类型的默认值是为false。但是某些配置文件的默认值是人为定义的。*  
布尔类型的变量只能为true或false。  
```java
boolean flag=true; //定义flag为true
```
### 数值的自动转换 
在程序中已经定义好了数据类型的变量，若是想用另一种数据类型表示时，Java会在下列的条件皆成立时自动做数据类型的转换：  
* 转换前的数据类型与转换后的数据类型兼容  
* 转换后的数据类型的表示范围比转换前的类型大  
如：
```java
System.out.println("10/3="+(10/3));     //10/3=3
System.out.println("10/3="+(10f/3));    //10/3=3.3333333
System.out.println("10/3="+(10/3f));    //10/3=3.3333333
System.out.println("10/3="+(10d/3));    //10/3=3.3333333333333335
System.out.println("10/3="+(10/3d));    //10/3=3.3333333333333335
```
10除以3因为其默认的类型是int型，所以第一条输出结果也省去了小数点后面的结果，直接输出int型。而后面在除数和被除数中加入`f`与`d`定义了除数或被除数的类型，其结果也自然而然变成了我们定义的那个类型了。  
> 另外由于小数默认定义的类型就是double，所以10/3.5输出的结果也会是double型。  

#### String型
String表示的是字符串，在输出的时候，所有的数据类型都向String类型进行转换。
String不是基本数据类型，属于引用数据类型，具体的我也不是很明白，可以去[这里](https://blog.csdn.net/qauchangqingwei/article/details/80831797)看看。  
```java
String str1="孙笑川";   //str1代表的字符串 是孙笑川
String str2="网恋被骗";     //str2代表的是 网恋被骗
int m=8000;     //m代表8000
System.out.println(str1+str2+m);
str1= str1+str2+m;      //修改str1的内容为 孙笑川+网恋被骗+8000
System.out.println(str1);
```
> 上面两次输出的值都是一样的，另外还要注意的是`String`首字母必须要大写，就和`System.out.println`的`System`一样.

### 数值的强制转换
> 当两个整数运算时，其运算结果也会是整数。（参考[自动转换](#数值的自动转换)）
举例来说，当作整数除法8/3的运算，其输出结果为整数2，而不是实际的2.33333…因此，在java中若是想要得到计算的结果是浮点数（带小数）时，就必须将数据类型做强制性的转换，转换的语法如下：

```java
float Q1=30.3333f;  //定义Q1的值为float类
int Q2=(int) Q1;    //将转换为int的Q1的值赋予Q2
System.out.println("Q2的值为："+ Q2);   //此时输出的为Q1转换为int的值
System.out.println("10除以3的结果为："+(float)(10/3));  /**错误用法
这里是先运算出3的结果再将结果转换为float*/
System.out.println("10除以3的结果为："+((float)10/3));  /**正确用法
定义运算过程为float，然后再进行运算，此时的结果为正常结果*/
/**输出结果为：
Q2的值为：30
10除以3的结果为：3.0
10除以3的结果为：3.3333333
*/
```

简单转换(Q2那一行)的话用法是
```java
(想要转换数据类型) 变量名称;
int Q2=(int) Q1;    //Q1属于float类型
```
另外输出时括号括括号有小学数学内味了，不过那会是{[()]}罢了

### 单元小结
1. Java中的[数据类型](#基本数据类型)划分
2. 八种基本数据类型，包括长度的，产量的默认值。
3. `String`，任何类型都会先String进行转换。

## 运算符与表达式
### 运算符  
> 表达式，表达式是由**操作数**与**运算符**所组成：**操作数**可以是常量、变量、也可以是方法，而**运算符**就是数学中的运算符号，如"+"、"-"、"*"、"/"、"%"(加减乘除余)等。  

```java
System.out.println(z+100);
// z与100都是操作数 而+就是运算符
```

常见的运算符有：  
| 赋值运算符号 | 描述 |   
|:----:|:----:|  
|\=|赋值|

使用例：
```java
String cloud="sb";
```

| 一元运算符 | 描述 | 
|:----:|:----:| 
|\+|正号|
|\-|符号|
|\!|NOT，否|

使用例：  
```java
boolean b=false;
int x=10;
int y=-30;
System.out.println("b="+b+", !b="+ !b); //取反
System.out.println("x="+x+", -x"+ -x);  //使用负号
System.out.println("y="+y+", +y"+ +y);  //使用正号 
```
> 最后一行输出的值依旧是`-30`，一开始我还挺疑惑的，还去问了问网友，结果被笑话了。因为负正得负，同项为正，异项为负。  

| 算术运算符 | 描述 |  
|:----:|:----:|  
 |+ |加法|
| - |减法|
| * |乘法|
| \/ |除法|
| % |取模(求余数)|  
使用例：
```java
int i=10;
int j=3;
System.out.println(i+"+"+j+"="+(i=j));  //加法操作
System.out.println(i+"-"+j+"="+(i-j));  //减法操作
System.out.println(i+"*"+j+"="+(i*j));  //乘法操作
System.out.println(i+"/"+j+"="+(i/j));  //除法操作
System.out.println(i+"%"+j+"="+(i%j));  //取模操作
```

| 自增自减运算符 | 描述 |  
|:----:|:----:|  
|++|自增，变量值加1|
|--|自减，变量值减1|  
使用例：
```java
int a=3,b=3;
int x=6,y=6;
System.out.println("a="+a);
System.out.println("\t a++ ="+(a++)+",a ="+a);  //先计算后自增
System.out.println("b ="+b);
System.out.println("\t ++b"+(++b)+",b ="+b);    //先自增后计算
System.out.println("x ="+x);
System.out.println("\t x-- ="+(x--)+",x ="+x);  //先计算后自增
System.out.println("y ="+y);
System.out.println("\t --y ="+(--y)+",y ="+y);  //先自增后计算
```
**`x++/x--`的话是先计算x的值再进行输出，要想输出自增/减后的值需要再次输出一次。而`++x/--x`的话是先进行自增/减，再进行计算输出值,能够直接输出自增/自减后的值，不用再次输出结果。**  
| 逻辑运算符 | 描述 |  
| :----: | :----: |  
|&|AND,与|
|&&|短路与|
| \| |OR,或|
| \|\| |短路或|
逻辑运算符就和boolean有点关系了，因为逻辑运算符就是用来判断真假的，其中加了**短路**的代表如果有一个为真/假，那么立即输出一个真/假的结果，不再进行后面的判断。  
* & 与：
  * 要求前后几个表达式的内容都要是`true`，最终结果才会是`true`。如果有一个是`false`,那最终结果就是`false`
  * 所有为真才为真，一假全假
* && 短路与
  * 读取到一个假立马输出假，后续不进行判断
* \| 或：
  * 要求前后几个表达式只有一个为`true`则最终结果就是`true`。如果全部是`false`，最终结果才为`false`
  * 所有为假才为假，一真全真
* \|\| 短路或
  * 读取到一个真立即输出一个真，后续不进行判断

> 关于短路逻辑运算符一开始我也不太明白，虽然特性与一般的逻辑运算符没啥差。后面找了找资料可算是明白了些。  

“[南城的人](https://www.jianshu.com/p/f04bc86c52d1)”写的这篇文章解释了一下区别，但是一开始我也没怎么看懂。这边稍微改写一下：
```java
if((23==23)||(100/0==0)){     //计算100/0会报错 
    System.out.println("真");
}else{
    System.out.println("假");
}
```  
此时的输出结果为“真”，且未报错。因为短路或的特性为“一个真即输出真，后续不进行判断”。  
如果我们把`||`改成`|`的话，输出的将会变成一段错误代码，原因是或(包括与)会对两边的值都进行一边判断，就算第一次判断已经满足了条件。然后`(100/0==0)`本身算是一个BUG，因为在数学里除数不能为0。  
同理:
```java
if((23==32)&&(100/0==0)){
    System.out.println("真");
}else{
    System.out.println("假");
}
```
此时输出的结果为“假”，假如这是把`&&`换成`&`的话，依旧会报错，因为`&`也会判断所有条件。如果换成`||`依旧会出错，因为`(23==32)`为`false`，不满足短路或的输出条件(true)。 

---
另外还有一篇文章也不错，是[QQ天堂](https://www.cnblogs.com/QQParadise/articles/1741617.html)写的短路效应的理解，这篇可以很直观的明白短路效应。  
实例:
```java
int x,y=10;
if(((x=0)==0)||((y=20)==20)){
    System.out.println("现在y的值为："+y);      //现在y的值为：10
}
int a,b=10;
if(((a=0)==0)|((b=20)==20)){
    System.out.println("现在b的值为："+b);      //现在b的值为：20
}
```
第一段if:**短路或**直接判断0=0为true之后直接输出了true，便运行了下一行的输出，直接舍去了后面`(y=20)`的赋值，所以y的值为一开始的10。      
第二段if:**或**在进行了两次赋值之后判断两边的条件都为true之后才输出了true，这时两边的赋值已经完成，故此时输出的b的值为20。    

---

















<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://cdn.jsdelivr.net/gh/Small-tailqwq/img/2020-11/88x31.png" /></a><br />本作品由<a xmlns:cc="http://creativecommons.org/ns#" href="https://hayasa.xyz/" property="cc:attributionName" rel="cc:attributionURL">Ko_teiru</a>采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。











